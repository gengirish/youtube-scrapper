const USER_AGENT =
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36";

const PIPED_INSTANCES = [
  "https://pipedapi.kavin.rocks",
  "https://pipedapi.adminforge.de",
  "https://api.piped.yt",
];

const INVIDIOUS_INSTANCES = [
  "https://inv.nadeko.net",
  "https://invidious.nerdvpn.de",
  "https://invidious.jing.rocks",
];

export interface TranscriptSegment {
  text: string;
  offset: number;
  duration: number;
}

export interface AvailableLanguage {
  code: string;
  name: string;
  is_generated: boolean;
}

export class TranscriptError extends Error {
  constructor(
    message: string,
    public statusCode: number = 500,
  ) {
    super(message);
    this.name = "TranscriptError";
  }
}

function decodeHtmlEntities(text: string): string {
  return text
    .replace(/&amp;/g, "&")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&#x27;/g, "'")
    .replace(/&#x2F;/g, "/")
    .trim();
}

// --- Strategy 1: Direct YouTube (works from non-cloud IPs) ---

interface CaptionTrack {
  baseUrl: string;
  languageCode: string;
  name: { simpleText?: string; runs?: Array<{ text: string }> };
  kind?: string;
}

function getTrackName(track: CaptionTrack): string {
  if (track.name?.simpleText) return track.name.simpleText;
  if (track.name?.runs) return track.name.runs.map((r) => r.text).join("");
  return track.languageCode;
}

async function tryDirectYouTube(
  videoId: string,
  language?: string,
): Promise<{
  segments: TranscriptSegment[];
  languages: AvailableLanguage[];
} | null> {
  try {
    const url = `https://www.youtube.com/watch?v=${videoId}&bpctr=9999999999&has_verified=1`;
    const response = await fetch(url, {
      headers: {
        "User-Agent": USER_AGENT,
        "Accept-Language": "en-US,en;q=0.9",
        Cookie: "CONSENT=YES+cb.20210328-17-p0.en+FX+688",
      },
    });

    if (!response.ok) return null;
    const html = await response.text();

    if (html.includes('"status":"LOGIN_REQUIRED"')) return null;

    const captionsMatch = html.match(/"captionTracks":(\[.*?\])/);
    if (!captionsMatch) return null;

    const tracks: CaptionTrack[] = JSON.parse(captionsMatch[1]);
    if (tracks.length === 0) return null;

    const languages = tracks.map((t) => ({
      code: t.languageCode,
      name: getTrackName(t),
      is_generated: t.kind === "asr",
    }));

    const selected = language
      ? tracks.find((t) => t.languageCode === language) || tracks[0]
      : tracks[0];

    const sep = selected.baseUrl.includes("?") ? "&" : "?";
    const transcriptRes = await fetch(`${selected.baseUrl}${sep}fmt=json3`, {
      headers: { "User-Agent": USER_AGENT },
    });

    if (!transcriptRes.ok) return null;
    return { segments: parseJson3(await transcriptRes.json()), languages };
  } catch {
    return null;
  }
}

// --- Strategy 2: Piped API ---

interface PipedSubtitle {
  url: string;
  mimeType: string;
  name: string;
  code: string;
  autoGenerated: boolean;
}

async function tryPiped(
  videoId: string,
  language?: string,
): Promise<{
  segments: TranscriptSegment[];
  languages: AvailableLanguage[];
} | null> {
  for (const instance of PIPED_INSTANCES) {
    try {
      const res = await fetch(`${instance}/streams/${videoId}`, {
        headers: { "User-Agent": USER_AGENT },
        signal: AbortSignal.timeout(10000),
      });

      if (!res.ok) continue;

      const data = (await res.json()) as {
        subtitles?: PipedSubtitle[];
        title?: string;
      };

      const subs = data.subtitles;
      if (!subs || subs.length === 0) continue;

      const languages = subs.map((s) => ({
        code: s.code,
        name: s.name,
        is_generated: s.autoGenerated,
      }));

      const selected = language
        ? subs.find((s) => s.code === language) || subs[0]
        : subs[0];

      const subRes = await fetch(selected.url, {
        signal: AbortSignal.timeout(10000),
      });
      if (!subRes.ok) continue;

      const vttText = await subRes.text();
      const segments = parseVTT(vttText);
      if (segments.length > 0) return { segments, languages };
    } catch {
      continue;
    }
  }
  return null;
}

// --- Strategy 3: Invidious API ---

interface InvidiousCaption {
  label: string;
  languageCode: string;
  url: string;
}

async function tryInvidious(
  videoId: string,
  language?: string,
): Promise<{
  segments: TranscriptSegment[];
  languages: AvailableLanguage[];
} | null> {
  for (const instance of INVIDIOUS_INSTANCES) {
    try {
      const res = await fetch(
        `${instance}/api/v1/captions/${videoId}`,
        {
          headers: { "User-Agent": USER_AGENT },
          signal: AbortSignal.timeout(10000),
        },
      );

      if (!res.ok) continue;

      const data = (await res.json()) as {
        captions?: InvidiousCaption[];
      };

      const captions = data.captions;
      if (!captions || captions.length === 0) continue;

      const languages = captions.map((c) => ({
        code: c.languageCode,
        name: c.label,
        is_generated: c.label.toLowerCase().includes("auto"),
      }));

      const selected = language
        ? captions.find((c) => c.languageCode === language) || captions[0]
        : captions[0];

      const captionUrl = selected.url.startsWith("http")
        ? selected.url
        : `${instance}${selected.url}`;

      const subRes = await fetch(captionUrl, {
        signal: AbortSignal.timeout(10000),
      });
      if (!subRes.ok) continue;

      const vttText = await subRes.text();
      const segments = parseVTT(vttText);
      if (segments.length > 0) return { segments, languages };
    } catch {
      continue;
    }
  }
  return null;
}

// --- Parsers ---

function parseJson3(
  data: {
    events?: Array<{
      tStartMs?: number;
      dDurationMs?: number;
      segs?: Array<{ utf8: string }>;
    }>;
  },
): TranscriptSegment[] {
  const events = data?.events || [];
  const segments: TranscriptSegment[] = [];

  for (const event of events) {
    if (event.segs) {
      const rawText = event.segs.map((s) => s.utf8 || "").join("");
      const text = decodeHtmlEntities(rawText).replace(/\n/g, " ").trim();
      if (text) {
        segments.push({
          text,
          offset: (event.tStartMs || 0) / 1000,
          duration: (event.dDurationMs || 0) / 1000,
        });
      }
    }
  }

  return segments;
}

function parseVTT(vttContent: string): TranscriptSegment[] {
  const segments: TranscriptSegment[] = [];
  const blocks = vttContent.split(/\n\n+/);

  for (const block of blocks) {
    const lines = block.trim().split("\n");
    const timeLine = lines.find((l) => l.includes("-->"));
    if (!timeLine) continue;

    const [startStr, endStr] = timeLine.split("-->").map((s) => s.trim());
    const start = parseVTTTime(startStr);
    const end = parseVTTTime(endStr);

    const textLines = lines.slice(lines.indexOf(timeLine) + 1);
    const text = decodeHtmlEntities(
      textLines
        .join(" ")
        .replace(/<[^>]+>/g, "")
        .trim(),
    );

    if (text && start !== null && end !== null) {
      segments.push({
        text,
        offset: start,
        duration: Math.max(0, end - start),
      });
    }
  }

  return segments;
}

function parseVTTTime(timeStr: string): number | null {
  const clean = timeStr.replace(/[^\d:.]/g, "");
  const parts = clean.split(":");
  if (parts.length < 2) return null;

  if (parts.length === 3) {
    const [h, m, s] = parts;
    return (
      parseInt(h) * 3600 + parseInt(m) * 60 + parseFloat(s)
    );
  }

  const [m, s] = parts;
  return parseInt(m) * 60 + parseFloat(s);
}

// --- Main fetch function (tries all strategies) ---

export async function fetchYouTubeTranscript(
  videoId: string,
  language?: string,
): Promise<{
  segments: TranscriptSegment[];
  languages: AvailableLanguage[];
}> {
  // Strategy 1: Direct YouTube (fastest, works from non-cloud IPs)
  const directResult = await tryDirectYouTube(videoId, language);
  if (directResult && directResult.segments.length > 0) {
    return directResult;
  }

  // Strategy 2: Piped API (open-source YouTube proxy)
  const pipedResult = await tryPiped(videoId, language);
  if (pipedResult && pipedResult.segments.length > 0) {
    return pipedResult;
  }

  // Strategy 3: Invidious API (another open-source proxy)
  const invidiousResult = await tryInvidious(videoId, language);
  if (invidiousResult && invidiousResult.segments.length > 0) {
    return invidiousResult;
  }

  throw new TranscriptError(
    "Could not fetch transcript. YouTube may be blocking cloud requests, or the video may not have captions enabled.",
    404,
  );
}
